# Context Engine v2 — Cursor Rules
# Full product build. Elasticsearch-powered feedback intelligence platform for PMs.

## Before Writing ANY Code

1. **Read PROJECT.md** to understand the full system
2. **Read UX.md** to understand every screen and interaction
3. **Read TASKS.md** to know which phase you're on
4. **Read the current phase spec** (docs/PHASE_X_SPEC.md) for exact requirements
5. **Clarify scope** — state what you're about to do and why
6. **Plan the approach** — list files you'll touch and what changes
7. **Only then write code**

## Execution Rules

- **One task at a time.** Complete it, test it, commit it. Then move on.
- **Minimal changes.** Only touch files required for the current task. No "while we're here" edits.
- **No guessing.** If you don't know an Elasticsearch API or a React pattern, say so. Don't invent syntax.
- **No placeholders.** Every function must be complete and working. No # TODO or pass left behind.
- **No dead code.** Don't leave commented-out blocks or unused imports.
- **Test before declaring done.** Run the code. Verify it works. Show the output.
- **Follow the phase spec exactly.** Don't add features from later phases. Don't skip things in the current phase.

## When You're Done

- State what you changed and why
- List every file modified
- Flag any risks or assumptions
- Suggest the git commit message (format: type: short description)
- Commit types: feat, fix, docs, data, refactor, test, chore

## When You're Stuck

- Say "I'm not sure about X" instead of guessing
- Suggest 2 approaches and let the human pick
- Reference docs: https://www.elastic.co/docs
- If something fails 3 times, STOP and explain what's happening instead of looping

## Python Standards

- Python 3.11+ only
- Type hints on ALL function signatures. No exceptions.
- Docstrings on ALL functions. Brief is fine but must exist.
- f-strings for formatting. Never .format() or %.
- pathlib for file paths. Never os.path.
- PEP 8 naming: snake_case functions/variables, PascalCase classes
- Functions under 50 lines. Split if longer.
- Pydantic for all data models and schemas
- Imports: stdlib first, third-party second, local third. Blank line between groups.
- Use logging module, not print.
- Always catch specific exceptions, never bare except:
- Elasticsearch calls MUST have try/except with meaningful error messages

## Elasticsearch Rules

- Single client instance via backend/app/es_client.py. Never create new clients elsewhere.
- API key auth only (cloud_id + api_key). Never username/password.
- Bulk API for 10+ documents. Never loop individual index calls.
- Always check bulk response for errors.
- Always include size parameter in queries — never rely on defaults.
- Always handle empty results gracefully.
- Use ES|QL for aggregations: FROM index | WHERE condition | STATS agg BY field | SORT field
- Use ELSER for semantic search via semantic_text field type.
- Hybrid search (keyword + semantic) for all user-facing search.
- Every query MUST filter by org_id for multi-tenancy.
- Never use match_all in production queries.
- Never hardcode index names — use config.
- Never assume a field exists — check mapping first.

## React / Frontend Standards

- TypeScript strict mode. No any types unless absolutely unavoidable.
- Functional components only. No class components.
- Tailwind CSS for styling. No inline styles. No CSS modules.
- Dark mode via Tailwind class strategy. Every component must support dark mode.
- React Router for navigation. No custom routing.
- Axios with interceptors for API calls. JWT in Authorization header.
- Lucide React for all icons. Consistent icon set.
- Components under 150 lines. Split if longer.
- Custom hooks for shared logic. No duplicated fetch/state logic.
- All API responses typed with TypeScript interfaces.
- Loading states on every data fetch.
- Error handling on every API call — show user-friendly message.
- Empty states on every page that can have no data.

## API Response Shapes

All endpoints follow these shapes consistently:

Success (single item):  { "data": { ... } }
Success (list):         { "data": [...], "pagination": { "page": 1, "page_size": 20, "total": 100 } }
Error:                  { "detail": "Human-readable error message" }

All endpoints prefixed with /api/v1/.

## Git Rules

- Commit after EVERY working feature. Small, frequent commits.
- Format: type: short description
- Types: feat, fix, docs, data, refactor, test, chore
- Work on main. No branch overhead.
- Never commit: .env, __pycache__, node_modules, .DS_Store

## Project Structure

    context-engine-v2/
    ├── docker-compose.yml
    ├── .env.example / .env
    ├── .gitignore
    ├── .cursorrules              # This file
    ├── PROJECT.md                # Product vision (read first)
    ├── UX.md                     # Every screen and interaction
    ├── TASKS.md                  # Phase overview and status
    ├── README.md                 # For users/judges
    ├── LICENSE                   # MIT
    ├── backend/
    │   ├── Dockerfile
    │   ├── requirements.txt
    │   └── app/                  # FastAPI application
    │       ├── main.py
    │       ├── config.py
    │       ├── es_client.py
    │       ├── dependencies.py
    │       ├── models/
    │       ├── schemas/
    │       ├── routers/
    │       ├── services/
    │       └── utils/
    ├── frontend/
    │   ├── Dockerfile
    │   ├── package.json
    │   └── src/                  # React application
    │       ├── App.tsx
    │       ├── components/
    │       ├── pages/
    │       ├── hooks/
    │       ├── services/
    │       ├── types/
    │       └── utils/
    └── docs/
        └── PHASE_X_SPEC.md       # Detailed spec per phase

## Non-Negotiable

- **Elasticsearch is the only datastore.** No PostgreSQL, no SQLite, no Redis. Everything goes in ES.
- **Multi-tenancy from day one.** org_id on every document, every query.
- **Dark mode on every page.** No white flash, no unstyled elements.
- **Agent chat bubble visible on every authenticated page.**
- **docker compose up starts everything.** No manual steps besides .env.
- **Phase specs are the source of truth.** If the spec says build X, build X. If it says don't build Y, don't build Y.
